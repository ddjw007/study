# 进程的基本概念

进程是一个具有独立功能的程序对某个数据集在处理机上的执行过程，进程也是资源分配的基本单位。

### 进程与程序的关系
- 进程和程序是相辅相成的。
- 进程是一个动态概念，而程序则是一个静态概念。
- 进程具有并行性特征。


## 进程的描述

从构成上来讲，进程由
- 进程块(Process Control Block,PCB)，主要包括进程的一些描述信息，资源信息以及控制信息等，是进程存在的唯一标识，是进程动态特征的集中反映。
- 有关的程序段
- 操作的数据集

#### 进程块的主要内容
- 进程标识
- 状态信息
- 进程的优先级
- CPU现场信息
- 资源清单
- 队列指针
- 其他

### :ledger: task_struct结构
Linux中的每个进程都由一个task_struct数据结构来表示。

task_struct其实就是通常意义上的进程控制块，也称为进程描述符，系统正是通过task_struct结构对进程进行有效管理和控制的。

task_struct结构包含的数据比较庞大:按功能主要可以分为：

- 进程标识符信息
- 进程调度信息
- 进程间通信信息
- 时间和定时器信息
- 进程链接信息
- 文件系统信息
- 虚拟内存消息
- 处理器特定信息

#### :evergreen_tree: 进程标识符信息

包括：进程标识符、用户标识符、组标识符等信息。

每个进程都有一个唯一的进程标识符(Process ID, PID)。PID是32位的无符号整数，存放在进程描述符的PID域中，它被顺序编号

每个进程都属于某个用户和某个用户组，

进程描述符中定义了多种类型的用户标识符和组标识符，比如：用户标识符(UID)、有效用户标识符(eUID)和组标识符(GID)、有效组标识符(eGID)

#### :evergreen_tree: 进程调度信息

调度程序利用这些信息来决定系统中哪个进程最迫切需要运行，并采用适当的策略来保证系统运转的的公平性和高效性。

#### :evergreen_tree: 进程间通信信息

Linux支持多种不同形式的进程间通信机制，如信号、管道。

进程描述符中主要有这些域与进程通信相关：
- sig,信号处理函数，包括自定义的和系统默认的处理函数；
- blocked,进程所能接受
- semsleeping,与信号量相关的等待队列，每一信号量集合对应一个等待队列。

#### :evergreen_tree: 进程链接信息

除了初始化进程init外，其他所有进程都有一个父进程，可以通过fork或clone系统调用来创建子进程。

#### :evergreen_tree: 时间和定时器信息

内核需要记录进程的创建时间以及在其生命周期内消耗的CPU时间.

进程耗费的CPU时间有两部分组成：用户态下耗费的时间和内核态下耗费的时间。

#### :evergreen_tree: 文件系统信息

进程经常会访问文件系统资源，打开或关闭文件，Linux内核要对进程使用文件的情况进行记录。

#### :evergreen_tree: 虚拟内存信息

Linux采用按需分页的策略来解决进程的内存需求，当物理内存不足时，Linux内存管理系统需要把内存中的部分页面交换到外存。

#### :evergreen_tree: 处理器特定信息


### :fallen_leaf: 进程的标识符

进程标识符也称进程识别码(Process Identification,PID),可以用来唯一标识进程。

PID是进程运行时系统随机分配的，在进程运行时，PID是不会改变的，进程结束，PID回收，之后重新分配。


### :sunflower: PID文件

## :sunflower: 进程的创建

### :leaves: 5.3.1 使用fork创建进程

Linux可以通过执行系统调用函数`fork`来创建新进程。

由`fork`创建的新进程被称为子进程，该函数调用一次，但返回两次。其中，子进程返回值是0，父进程的返回值是子进程的PID。

系统调用函数`fork`的声明如下：

```C++
#include <unistd.h>
pid_t fork();
```

该函数将创建一个子进程，如果成功，在父进程的程序中将返回子进程的线程ID，即PID；在子进程中函数则返回0.

一个进程如果成功调用`fork`函数，系统先给新进程分配资源(存储数据和代码的空间)，然后吧原来的进程的所有值都复制到新的进程中。

### :leaves: 5.3.2 使用exec创建进程

`exec`创建的进程就是，新创建的进程会占据原来的进程，而表面(PID)上就看起来依然不变：

函数`exec`声明如下
```C++
#include <unistd.h>
int execl(const char *path,const char *arg,...)
```

### :leaves: 5.3.2 使用system创建进程

`system`函数通过调用`shell`程序来执行所传入的命令，相当与先`fork()`,再`exec()`.

该函数的特点是源进程和子进程各自运行，且源进程需要等子进程运行完再继续。

该函数声明如下：
```C++
#include <stdlib.h>
int system(const char *command);
```






